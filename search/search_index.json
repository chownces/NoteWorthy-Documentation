{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to NoteWorthy NoteWorthy is a desktop notetaking app which seeks to combine the best of features in the industry into a compelling package for students to create, manage and collaborate on their notes. This project is done as part of the Orbital Summer Programme 2021 (CP2106 - Independent Software Development Project) at the National University of Singapore (NUS), by En Rong @chownces and Aiken @aikenwx . The stable branch is deployed at https://noteworthy-prod.vercel.app/ . Do note that the app might take some time to start up as the backend is hosted on Heroku's free tier. Documentation All the documentation for this project can be found on this webpage, and can be accessed via the navigation links on the left. Repositories Our repositories can be found at the following links: Frontend: https://github.com/chownces/NoteWorthy Backend: https://github.com/chownces/NoteWorthy-API Tech Stack This project uses a MERN stack with GraphQL: Frontend: ReactJS, Semantic-UI Backend: Express, Apollo, GraphQL, MongoDB Deployment This project is deployed on the following platforms: Frontend: Vercel Backend: Heroku Database: MongoDB Atlas","title":"Home"},{"location":"#welcome-to-noteworthy","text":"NoteWorthy is a desktop notetaking app which seeks to combine the best of features in the industry into a compelling package for students to create, manage and collaborate on their notes. This project is done as part of the Orbital Summer Programme 2021 (CP2106 - Independent Software Development Project) at the National University of Singapore (NUS), by En Rong @chownces and Aiken @aikenwx . The stable branch is deployed at https://noteworthy-prod.vercel.app/ . Do note that the app might take some time to start up as the backend is hosted on Heroku's free tier.","title":"Welcome to NoteWorthy"},{"location":"#documentation","text":"All the documentation for this project can be found on this webpage, and can be accessed via the navigation links on the left.","title":"Documentation"},{"location":"#repositories","text":"Our repositories can be found at the following links: Frontend: https://github.com/chownces/NoteWorthy Backend: https://github.com/chownces/NoteWorthy-API","title":"Repositories"},{"location":"#tech-stack","text":"This project uses a MERN stack with GraphQL: Frontend: ReactJS, Semantic-UI Backend: Express, Apollo, GraphQL, MongoDB","title":"Tech Stack"},{"location":"#deployment","text":"This project is deployed on the following platforms: Frontend: Vercel Backend: Heroku Database: MongoDB Atlas","title":"Deployment"},{"location":"getting-started/backendsetup/","text":"Getting Started The instructions for backend setup can be found on this page. Backend MongoDB Database Setup Install and start MongoDB by following the instructions on their installation site . Express Server Setup Install a stable version of NodeJS. The LTS or current version should work fine. Clone this repository , and navigate to it using cd in your command line. Run yarn install to install the dependencies. Copy the .env.example file to .env , and configure the environment variables (more details below ). Run yarn start to start the local server at localhost:4300 . Navigate to localhost:4300/graphql to interact with the GraphQL Console. Environment Configuration MONGODB_URI : The URL to your MongoDB database. By default, the local development database can be found at mongodb://localhost:27017/your_database_name (replace your_database_name with the actual name of your database). MONGODB_USERNAME : The username of your MongoDB account ( optional for local development). MONGODB_PASSWORD : The password to your MongoDB account ( optional for local development). CORS_ORIGIN : The URL of your frontend. Use localhost:3000 for local development. SESSION_SECRET : A randomly generated string for initializing express-session . Testing Please format your code with yarn format and run the test suite via yarn test before pushing and issuing a PR.","title":"Backend Setup"},{"location":"getting-started/backendsetup/#getting-started","text":"The instructions for backend setup can be found on this page.","title":"Getting Started"},{"location":"getting-started/backendsetup/#backend","text":"","title":"Backend"},{"location":"getting-started/backendsetup/#mongodb-database-setup","text":"Install and start MongoDB by following the instructions on their installation site .","title":"MongoDB Database Setup"},{"location":"getting-started/backendsetup/#express-server-setup","text":"Install a stable version of NodeJS. The LTS or current version should work fine. Clone this repository , and navigate to it using cd in your command line. Run yarn install to install the dependencies. Copy the .env.example file to .env , and configure the environment variables (more details below ). Run yarn start to start the local server at localhost:4300 . Navigate to localhost:4300/graphql to interact with the GraphQL Console.","title":"Express Server Setup"},{"location":"getting-started/backendsetup/#environment-configuration","text":"MONGODB_URI : The URL to your MongoDB database. By default, the local development database can be found at mongodb://localhost:27017/your_database_name (replace your_database_name with the actual name of your database). MONGODB_USERNAME : The username of your MongoDB account ( optional for local development). MONGODB_PASSWORD : The password to your MongoDB account ( optional for local development). CORS_ORIGIN : The URL of your frontend. Use localhost:3000 for local development. SESSION_SECRET : A randomly generated string for initializing express-session .","title":"Environment Configuration"},{"location":"getting-started/backendsetup/#testing","text":"Please format your code with yarn format and run the test suite via yarn test before pushing and issuing a PR.","title":"Testing"},{"location":"getting-started/frontendsetup/","text":"Getting Started The instructions for frontend setup can be found on this page. Frontend ReactJS Setup Install a stable version of NodeJS. The LTS or current version should work fine. Clone this repository , and navigate to it using cd in your command line. Run yarn install to install the dependencies. Copy the .env.example file to .env , and configure the environment variables (more details below ). Run yarn start to start the local server at localhost:3000 . Navigate to localhost:3000 on your browser. Environment Configuration REACT_APP_BACKEND_URL : Specify the URL of your backend. By default, the local development backend can be found at http://localhost:4300/graphql/ . REACT_APP_ROOT_PATH : Specify the root URL of your frontend. By default, the local development frontend can be found at http://localhost:3000/ Testing Please format your code with yarn format and run the test suite via yarn test before pushing and issuing a PR.","title":"Frontend Setup"},{"location":"getting-started/frontendsetup/#getting-started","text":"The instructions for frontend setup can be found on this page.","title":"Getting Started"},{"location":"getting-started/frontendsetup/#frontend","text":"","title":"Frontend"},{"location":"getting-started/frontendsetup/#reactjs-setup","text":"Install a stable version of NodeJS. The LTS or current version should work fine. Clone this repository , and navigate to it using cd in your command line. Run yarn install to install the dependencies. Copy the .env.example file to .env , and configure the environment variables (more details below ). Run yarn start to start the local server at localhost:3000 . Navigate to localhost:3000 on your browser.","title":"ReactJS Setup"},{"location":"getting-started/frontendsetup/#environment-configuration","text":"REACT_APP_BACKEND_URL : Specify the URL of your backend. By default, the local development backend can be found at http://localhost:4300/graphql/ . REACT_APP_ROOT_PATH : Specify the root URL of your frontend. By default, the local development frontend can be found at http://localhost:3000/","title":"Environment Configuration"},{"location":"getting-started/frontendsetup/#testing","text":"Please format your code with yarn format and run the test suite via yarn test before pushing and issuing a PR.","title":"Testing"},{"location":"project-overview/postervideo/","text":"Project Overview Poster Video","title":"Poster and Video"},{"location":"project-overview/postervideo/#project-overview","text":"","title":"Project Overview"},{"location":"project-overview/postervideo/#poster","text":"","title":"Poster"},{"location":"project-overview/postervideo/#video","text":"","title":"Video"},{"location":"project-overview/problemmotivation/","text":"Project Overview Problem Motivation As university students, we are very selective of where we write our notes. Although there are many note taking apps out there, each one only truly excels in their own unique form of note taking (e.g. OneNote for handwritten notes, Google Docs for collaboration, Notion for database-style organisation). Worse still, some feature-rich ones require subscription fees. This can be annoying for university students, who are forced to make a compromise between features and also cost. We have identified a core set of features that students seek in their note-taking apps. Offering superb organisation, the ability to jot on the go, easy collaboration, and time management features, NoteWorthy combines the best features of note taking apps out there into a compelling package for students, by students. Proposed level of achievement: Apollo Proposed Core Features Login into the app and retrieve their own notes View notes in a simple 'Table' view or a Kanban-style 'Board' view Drag notes around in the above-mentioned database views to organise them Note pages are composed of draggable and editable blocks Upload pictures and screenshots to notes Share notes with others via online links Download and convert notes into printable pdf","title":"Problem Motivation & Core Features"},{"location":"project-overview/problemmotivation/#project-overview","text":"","title":"Project Overview"},{"location":"project-overview/problemmotivation/#problem-motivation","text":"As university students, we are very selective of where we write our notes. Although there are many note taking apps out there, each one only truly excels in their own unique form of note taking (e.g. OneNote for handwritten notes, Google Docs for collaboration, Notion for database-style organisation). Worse still, some feature-rich ones require subscription fees. This can be annoying for university students, who are forced to make a compromise between features and also cost. We have identified a core set of features that students seek in their note-taking apps. Offering superb organisation, the ability to jot on the go, easy collaboration, and time management features, NoteWorthy combines the best features of note taking apps out there into a compelling package for students, by students. Proposed level of achievement: Apollo","title":"Problem Motivation"},{"location":"project-overview/problemmotivation/#proposed-core-features","text":"Login into the app and retrieve their own notes View notes in a simple 'Table' view or a Kanban-style 'Board' view Drag notes around in the above-mentioned database views to organise them Note pages are composed of draggable and editable blocks Upload pictures and screenshots to notes Share notes with others via online links Download and convert notes into printable pdf","title":"Proposed Core Features"},{"location":"project-overview/projectlog/","text":"Date Aiken hours Description En Rong hours Description 25/04/2021 - - 2 GitHub Repo setup 30/04/2021 - - 4 Added CI checks and tests 01/05/2021 - - 6 Connected frontend to GraphQL backend. Added basic block dragging functionality in notepage 02/05/2021 - - 4 Handle blocks updates in backend. Added an all notes summary page 09/05/2021 - - 2 Updated Apollo InMemoryCache implementation 10/05/2021 - - 6 Updated frontend caching and blocks updates in backend 11/05/2021 - - 6 Added routing in the frontend, and responsive navbar, loading and 404 components 12/05/2021 - - 2 Added UI snapshot tests 13/05/2021 2 Read up Git commands 2 Added mockups for frontend tests 14/05/2021 4 First meeting with project mentor and project discussion regarding poster and video submission 4 First meeting with project mentor and project discussion regarding poster and video submission 14/05/2021 4 Read up ReactJS documentation 4 Read up on handling authentication on web apps (JWT) 15/05/2021 6 Mission Control #1 Workshops (ReactJS and HTML/ CSS/ JS) - - 15/05/2021 4 Poster and video for submission 4 Poster and video for submission 16/05/2021 2 Read-up semantic UI react API - - 17/05/2021 4 Created boardview template with semantic UI react - - 20/05/2021 5 Attempted to add context menu to noteblocks - - 21/05/2021 - - 4 Reading up on access and refresh token authentication flow 22/05/2021 - - 6 Implementing authentication with JWT access and refresh tokens 22/05/2021 2 Mission Control #2 Workshop (ReactJS) 2 Mission Control #2 Workshop (ReactJS) 24/05/2021 6 Reworked context menu for noteblocks, added delete and add row buttons 10 Added PassportJS and switched to sessions and cookies auth flow 25/05/2021 - - 2 Frontend logout 26/05/2021 - - 8 Update backend GraphQL resolvers and miscellaneous frontend updates 26/05/2021 - - 3 Deployment to MongoDB Atlas, Heroku and Vercel 28/05/2021 3 Read up GraphQL and Appollo API - - 28/05/2021 3 Attempted to add boardview/ tableview to notepages - - 29/05/2021 2 Team-meeting to update each other on implementations 2 Team-meeting to update each other on implementations 30/05/2021 - - 2 Added deleteNote and deleteDatabase mutations. Fixed login state bug in frontend. 01/06/2021 4 Added renaming functionality to components - - 02/06/2021 2 Reworked renaming functionality with react state props - - 02/06/2021 4 Encountered react state persistence bug when implementing alternative views, workaround with React-router links m - 04/06/2021 2 Fixed Git Pull Request merge issues and snapshot testing 2 Fixed Git PR merge issues and snapshot testing 06/06/2021 6 Familiarising with apollo and mongodb API - - 08/06/2021 4 Implemented categories as a property of notes, basic implementation of boardview - - 09/06/2021 2 Team meet to plan better implementation of categories and implemented alternative views using cache updates 2 Team meet for implementation of categories 09/06/2021 1 Fixed semantic ordering of components in context-menus - - 10/06/2021 6 Created handlers for adding, deleting and updating categories, created columns for boardview - - 11/06/2021 6 Made notes in boardview draggable between categories columns and rows, however encountered a react dnd bug - 14/06/2021 2 Debugging react-beautiful-dnd bug, replanned categories data structure 2 Debugging react-beautiful-dnd bug , replanned categories data structure 15/06/2021 8 Reimplemented categories as its own schema in backend, updated handlers, encountered bug when trying to populate categories - 16/06/2021 8 Fixed appollo bug, reimplemented draggable notes. Encountered visual bug when due to lag when dragging notes. - 18/06/2021 4 Fixed lag bug with apollo optimistic response - - 22/06/2021 - - 8 Review PR, refactor code in PR 23/06/2021 2 Added optimistic response to deleteNote handler to reduce lag in vercel deployment 3 Added database migrations and deployed updated version 23/06/2021 - - 4 Write documentation and deploy on GitHub Pages using mkdocs 24/06/2021 4 Tested optimistic response to createNote handler, still buggy 4 Fix Apollo mutation cache update resulting in cursor jumping to EOL bug in react-contenteditable component 01/07/2021 7 Implemented and tested various different CRUD handlers for recursive note blocks - - 03/07/2021 6 Research on how to pass recusively structured objects to frontend and testing - - 05/07/2021 7 Implemented noteblock query handlers to flatten recursive note block 'trees' into a single array to be passed to frontend - - 07/07/2021 2 Implemented handlers to indent blocks on a tab - - 07/07/2021 3 Styled indented note blocks, updated navigation function to help caret navigate through newly structured note blocks - - 07/07/2021 3 Fixed fatal bugs caused by getNote and updateNoteBlock handlers - - 08/07/2021 1 Cleaned up frontend and backend code - - 08/07/2021 3 Updated note block CRUD operators and indentBlock handler to work across different layers of note blocks - - 08/07/2021 2 Fixed non-updating note block text when indenting note-blocks - - 08/07/2021 2 Updated navigation function to allow it to navigate into indented note blocks - - 10/07/2021 3 Fixed crash bug when indenting note block under certain conditions - - 10/07/2021 2 Implemented unindent note block handler - - 11/07/2021 3 Updated backspace event within note blocks to unindent note block only when caret set to start of the note block - - 11/07/2021 3 Added handler to append to previous block upon backspace when a note block can no longer be unidented - - 14/07/2021 4 Added handlers to properly get and set caret positions in noteblocks. Caret position is now preserved when indenting blocks 2 Added more documentation on project documentation website 15/07/2021 - - 3 Research and implement GitHub workflow actions and setup dependabot 15/07/2021 - - 2 Added more documentation on implementation details on project website 16/07/2021 3 Fixed non-updating noteblocks by triggering a rerender everytime a note block loses focus 2 Read up on GraphQL backend testing 16/07/2021 2 Implemented handler to split note blocks upon enter key event along caret - - 17/07/2021 4 Research on how to implement draggable blocks in a recursive structure 8 Read up on GraphQL backend testing with MongoDB, and implemented tests for query resolvers 17/07/2021 - - 1 Added project documentation for test suites 17/07/2021 - - 1 Update miscellaneous readmes and project documentation 18/07/2021 - - 2 Read up on optimistic response, and reviewed PR on optimistic response for the note handlers 18/07/2021 - - 2 Improved the note and noteblock context menu UI/UX and accessibility 18/07/2021 - - 2 Improved notepage UI, and added the editable title block 19/07/2021 - - 2 Improve notepage and database dragging styling 20/07/2021 - - 4 Worked on board view dragging bugs, and overall look and UX 21/07/2021 - - 4 Refactored database views, implemented draggable columns with draggable notes in board view, miscellaneous UI updates 21/07/2021 - - 1 New backend resolver updates to match frontend requirements 22/07/2021 4 Basic side-bar for databases added as a popup button 4 Added documentation on skills learnt and challenges encountered 22/07/2021 3 More styling for side-bar added to fit overall theme of the app 1 Fix deployment bug due to mistakes in package.json 23/07/2021 3 Created draggable databases 2 Research on how to handle optimistic UI where IDs have yet to be returned from backend. Handled optimistic UI id bug for database views 24/07/2021 2 Work-around for styling bug in draggable databases created 6 Research on useMemo to prevent child component from rerendering (which causes react-contenteditable cursor to jump to the end of line). Handled uploading of images. Updated login button with loader. Added optimistic response UI for category creation. 24/07/2021 - - 1 Backend update to match frontend requirements 25/07/2021 6 Restyle, add draggable function and new CRUD operations to table view 4 Added link sharing feature. Slight UI improvements 25/07/2021 2 Updated frontend and backend functions to go to last visited databases on login. - - 26/07/2021 4 Debug styling bugs in table view and side bar, cleaned up code 6 Review Side navbar PR and fix miscellaneous bugs in the PR. Added migration file for that PR and deployed it. 26/07/2021 4 Update documentation, poster and video 2 Debugged race condition in backend. Wrote transactions for some resolvers. 26/07/2021 - - 2 Update documentation Total Hours Aiken En Rong 200 178","title":"Project Log"},{"location":"project-overview/timeline/","text":"Project Overview Timeline Milestone 1 (May 2021) Basic Notion-like note taking frontend, where users can type and edit word 'blocks' Milestone 2 (June 2021) Notetaking database and backend where persistence is added to the app User authentication and login UI Implement draggable 'blocks' feature within a notepage Basic CRUD operations for note 'blocks' and note pages Conceptualisation of 'Board' and 'Table' views for each database Deployment of project CI/CD and Workflow Setup Milestone 3 (July 2021) Update app UI based on peer feedback Final implementation of 'Board' and 'Table' views Improved context menu accessibility (UI/UX) Uploading of pictures and screenshots Link sharing Download as PDF Added snapshot and unit tests User testing and resolving bugs Future Extensions Indentable and nestable note blocks (partially implemented) Collabarative editing (partially implemented with WebSockets) Ability to add code blocks and LaTex syntax Add more text-formatting features like underline and italics ( bold is already implemented)","title":"Project Timeline"},{"location":"project-overview/timeline/#project-overview","text":"","title":"Project Overview"},{"location":"project-overview/timeline/#timeline","text":"","title":"Timeline"},{"location":"project-overview/timeline/#milestone-1-may-2021","text":"Basic Notion-like note taking frontend, where users can type and edit word 'blocks'","title":"Milestone 1 (May 2021)"},{"location":"project-overview/timeline/#milestone-2-june-2021","text":"Notetaking database and backend where persistence is added to the app User authentication and login UI Implement draggable 'blocks' feature within a notepage Basic CRUD operations for note 'blocks' and note pages Conceptualisation of 'Board' and 'Table' views for each database Deployment of project CI/CD and Workflow Setup","title":"Milestone 2 (June 2021)"},{"location":"project-overview/timeline/#milestone-3-july-2021","text":"Update app UI based on peer feedback Final implementation of 'Board' and 'Table' views Improved context menu accessibility (UI/UX) Uploading of pictures and screenshots Link sharing Download as PDF Added snapshot and unit tests User testing and resolving bugs","title":"Milestone 3 (July 2021)"},{"location":"project-overview/timeline/#future-extensions","text":"Indentable and nestable note blocks (partially implemented) Collabarative editing (partially implemented with WebSockets) Ability to add code blocks and LaTex syntax Add more text-formatting features like underline and italics ( bold is already implemented)","title":"Future Extensions"},{"location":"project-overview/implementationdetails/deployment/","text":"Implementation Deployment This project is deployed on the following cloud providers: Frontend: Vercel Backend: Heroku Database: MongoDB Atlas Vercel Vercel has free hosting for personal projects and CD that is easy to set up, which suited our needs. Heroku Heroku's generous free hosting plan and easy CD setup satisfied our need for a PaaS to host our backend. However, it does come with downsides such as the instance shutting down after 30 minutes of inactivity. This means that there will be 'cold starts' in our application after periods of inactivity resulting initial lag time when accessing the backend, which is okay at the moment as this project is not deployed for production use. MongoDB Atlas MongoDB's SaaS database clusters has a generous free tier which suited our deployment needs for showcasing our project. It is also easy and intuitive to set up.","title":"Deployment"},{"location":"project-overview/implementationdetails/deployment/#implementation","text":"","title":"Implementation"},{"location":"project-overview/implementationdetails/deployment/#deployment","text":"This project is deployed on the following cloud providers: Frontend: Vercel Backend: Heroku Database: MongoDB Atlas","title":"Deployment"},{"location":"project-overview/implementationdetails/deployment/#vercel","text":"Vercel has free hosting for personal projects and CD that is easy to set up, which suited our needs.","title":"Vercel"},{"location":"project-overview/implementationdetails/deployment/#heroku","text":"Heroku's generous free hosting plan and easy CD setup satisfied our need for a PaaS to host our backend. However, it does come with downsides such as the instance shutting down after 30 minutes of inactivity. This means that there will be 'cold starts' in our application after periods of inactivity resulting initial lag time when accessing the backend, which is okay at the moment as this project is not deployed for production use.","title":"Heroku"},{"location":"project-overview/implementationdetails/deployment/#mongodb-atlas","text":"MongoDB's SaaS database clusters has a generous free tier which suited our deployment needs for showcasing our project. It is also easy and intuitive to set up.","title":"MongoDB Atlas"},{"location":"project-overview/implementationdetails/techstack/","text":"Implementation Details This section will discuss the implementation details of our project, and briefly touch on the rationale behind our choices. Tech Stack We used a MERN stack with GraphQL for the implementation of the web app: Frontend: ReactJS, Semantic-UI Backend: Express, Apollo, GraphQL, MongoDB Diagram Repositories Our repositories can be found at the following links: Frontend: https://github.com/chownces/NoteWorthy Backend: https://github.com/chownces/NoteWorthy-API","title":"Tech Stack"},{"location":"project-overview/implementationdetails/techstack/#implementation-details","text":"This section will discuss the implementation details of our project, and briefly touch on the rationale behind our choices.","title":"Implementation Details"},{"location":"project-overview/implementationdetails/techstack/#tech-stack","text":"We used a MERN stack with GraphQL for the implementation of the web app: Frontend: ReactJS, Semantic-UI Backend: Express, Apollo, GraphQL, MongoDB","title":"Tech Stack"},{"location":"project-overview/implementationdetails/techstack/#diagram","text":"","title":"Diagram"},{"location":"project-overview/implementationdetails/techstack/#repositories","text":"Our repositories can be found at the following links: Frontend: https://github.com/chownces/NoteWorthy Backend: https://github.com/chownces/NoteWorthy-API","title":"Repositories"},{"location":"project-overview/implementationdetails/testing/","text":"Implementation Details Testing Unit tests are important in all software engineering projects. A properly written set of tests is vital in ensuring the 'correctness' of the program without manually checking each function and edge cases whenever there are changes or additions to the codebase. Although it might be a hassle to set up initially, unit tests are akin to long-term investments, and grant both cost and time savings as the piece of software continues to scale and grow. Below is a summary of the testing suite employed in this project. Jest As both our frontend and backend were written in JavaScript, Jest was the obvious testing framework to use, with its good documentation and ease of use. Frontend On the frontend, we mocked our GraphQL queries and used snapshot testing as our primary test suite. Snapshot testing, when done properly, is a useful tool for testing frontend code, as it ensures that our UI does not change unexpectedly. \"A typical snapshot test case renders a UI component, takes a snapshot, then compares it to a reference snapshot file stored alongside the test. The test will fail if the two snapshots do not match: either the change is unexpected, or the reference snapshot needs to be updated to the new version of the UI component.\" ~ A brief explanation of snapshot testing by Jest Backend As we were using GraphQL as opposed to the traditional RESTful API which uses route handlers, our unit tests were done around the GraphQL resolvers . Unfortunately, the documentation surrounding GraphQL resolver testing is still quite limited, and we spent a longer time than expected to get it working. Ultimately, we used mongodb-memory-server to start up an in-memory MongoDB test database which we seeded, and used Apollo Server's built-in executeOperation method to run unit tests against our resolvers. Extensions Due to the limited project timeframe and manpower, we settled with snapshot testing and backend unit tests. If we had more time, we would have looked into end-to-end testing and also defining a set of manual tests to validate our UI/UX.","title":"Testing"},{"location":"project-overview/implementationdetails/testing/#implementation-details","text":"","title":"Implementation Details"},{"location":"project-overview/implementationdetails/testing/#testing","text":"Unit tests are important in all software engineering projects. A properly written set of tests is vital in ensuring the 'correctness' of the program without manually checking each function and edge cases whenever there are changes or additions to the codebase. Although it might be a hassle to set up initially, unit tests are akin to long-term investments, and grant both cost and time savings as the piece of software continues to scale and grow. Below is a summary of the testing suite employed in this project.","title":"Testing"},{"location":"project-overview/implementationdetails/testing/#jest","text":"As both our frontend and backend were written in JavaScript, Jest was the obvious testing framework to use, with its good documentation and ease of use.","title":"Jest"},{"location":"project-overview/implementationdetails/testing/#frontend","text":"On the frontend, we mocked our GraphQL queries and used snapshot testing as our primary test suite. Snapshot testing, when done properly, is a useful tool for testing frontend code, as it ensures that our UI does not change unexpectedly. \"A typical snapshot test case renders a UI component, takes a snapshot, then compares it to a reference snapshot file stored alongside the test. The test will fail if the two snapshots do not match: either the change is unexpected, or the reference snapshot needs to be updated to the new version of the UI component.\" ~ A brief explanation of snapshot testing by Jest","title":"Frontend"},{"location":"project-overview/implementationdetails/testing/#backend","text":"As we were using GraphQL as opposed to the traditional RESTful API which uses route handlers, our unit tests were done around the GraphQL resolvers . Unfortunately, the documentation surrounding GraphQL resolver testing is still quite limited, and we spent a longer time than expected to get it working. Ultimately, we used mongodb-memory-server to start up an in-memory MongoDB test database which we seeded, and used Apollo Server's built-in executeOperation method to run unit tests against our resolvers.","title":"Backend"},{"location":"project-overview/implementationdetails/testing/#extensions","text":"Due to the limited project timeframe and manpower, we settled with snapshot testing and backend unit tests. If we had more time, we would have looked into end-to-end testing and also defining a set of manual tests to validate our UI/UX.","title":"Extensions"},{"location":"project-overview/implementationdetails/whytechstack/","text":"Implementation Details Why these technologies? Frontend ReactJS We settled with ReactJS as the library of choice in implementing our frontend as it is an industry standard for building web applications today. This allows us to learn skills relevant to the industry, and build a level of proficiency and familiarity in this library and its ecosystem, before moving on to bigger projects in the future. Backend Express For the backend, we chose to use Express as it is a commonly used backend framework for small to medium projects. Besides, the frontend was already written in TypeScript, and having prior experience with JavaScript syntax in CS1101S Programming Methodology would allow for a lower initial learning curve. GraphQL We chose GraphQL over the traditional RESTful API for this project for 2 main reasons : GraphQL is gaining lots of traction in the industry and amongst big name companies such as Airbnb and GitHub! Allows us to send queries to get the exact data we need without having to work with rigid server-defined endpoints. This is crucial as our notetaking app requires slightly different variations of data from the backend for different pages. This also means less work when implementing the API as we do not need multiple endpoints with specific shapes, while allowing the frontend to only query the data it needs! Over and above, GraphQL has a strong type system that is written down as a GraphQL schema . This schema defines the API, and serves as a contract between the client and backend, which tells the client how to access the data in the backend. This means that once the schema is defined, the frontend and backend teams can work independently and quicker since both are aware of the structure of data that is sent over the API! MongoDB As we are working with dynamically structured data, using a document NoSQL database like MongoDB is a no-brainer. Also, it is widely documented and well-integrated with NodeJS via libraries such as Mongoose . Deployment is also made easy with SaaS such as MongoDB Atlas .","title":"Why this tech stack?"},{"location":"project-overview/implementationdetails/whytechstack/#implementation-details","text":"","title":"Implementation Details"},{"location":"project-overview/implementationdetails/whytechstack/#why-these-technologies","text":"","title":"Why these technologies?"},{"location":"project-overview/implementationdetails/whytechstack/#frontend","text":"","title":"Frontend"},{"location":"project-overview/implementationdetails/whytechstack/#reactjs","text":"We settled with ReactJS as the library of choice in implementing our frontend as it is an industry standard for building web applications today. This allows us to learn skills relevant to the industry, and build a level of proficiency and familiarity in this library and its ecosystem, before moving on to bigger projects in the future.","title":"ReactJS"},{"location":"project-overview/implementationdetails/whytechstack/#backend","text":"","title":"Backend"},{"location":"project-overview/implementationdetails/whytechstack/#express","text":"For the backend, we chose to use Express as it is a commonly used backend framework for small to medium projects. Besides, the frontend was already written in TypeScript, and having prior experience with JavaScript syntax in CS1101S Programming Methodology would allow for a lower initial learning curve.","title":"Express"},{"location":"project-overview/implementationdetails/whytechstack/#graphql","text":"We chose GraphQL over the traditional RESTful API for this project for 2 main reasons : GraphQL is gaining lots of traction in the industry and amongst big name companies such as Airbnb and GitHub! Allows us to send queries to get the exact data we need without having to work with rigid server-defined endpoints. This is crucial as our notetaking app requires slightly different variations of data from the backend for different pages. This also means less work when implementing the API as we do not need multiple endpoints with specific shapes, while allowing the frontend to only query the data it needs! Over and above, GraphQL has a strong type system that is written down as a GraphQL schema . This schema defines the API, and serves as a contract between the client and backend, which tells the client how to access the data in the backend. This means that once the schema is defined, the frontend and backend teams can work independently and quicker since both are aware of the structure of data that is sent over the API!","title":"GraphQL"},{"location":"project-overview/implementationdetails/whytechstack/#mongodb","text":"As we are working with dynamically structured data, using a document NoSQL database like MongoDB is a no-brainer. Also, it is widely documented and well-integrated with NodeJS via libraries such as Mongoose . Deployment is also made easy with SaaS such as MongoDB Atlas .","title":"MongoDB"},{"location":"project-overview/implementationdetails/workflow/","text":"Implementation Details Workflow Version Control We used Git and GitHub as our code version control system. For collaboration, we used the pull request (PR) workflow to commit to our master branch. This enables us to stay up to date with what our partner is working on, and also have an extra pair of eyes on code quality. Continuous Integration and Continuous Delivery (CI/CD) We also decided to focus fairly heavily on learning the CI/CD side of DevOps in this project, as we found this knowledge to be invaluable to future software projects that we will be working on. The following is a short summary of the CI/CD workflow we have employed: Continuous Integration Pre-push checks We used husky to run pre-push Git hooks that do code linting, formatting checks and run tests locally before allowing the commit to be pushed to our GitHub repository This ensures that the code on GitHub is formatted and passing our tests before others review/ deploy it GitHub Actions We used GitHub workflow actions in our next step of CI to run the above checks again on GitHub's server to ensure everything is ok This time, we also build the application to ensure that it is ready for deployment GitHub Dependabot GitHub's Dependabot was also set up to check for dependency updates in the packages we use for this project This is extremely convenient as Dependabot automatically sets up PRs and runs our test suite whenever there are packages that can be updated Continuous Delivery Vercel Vercel has a bot that is well integrated with GitHub, and was set up to automatically deploy our production branch with our production configuration This streamlines our frontend deployment as all we have to do is just push to the production branch Heroku Heroku has a similar CD workflow as Vercel, and automatically deploys our production branch with our production configuration whenever there are changes A post-build script is also ran when there are new database migration files Database Migrations We also spent some time working on database migrations as having working knowledge in this aspect will be useful in future software projects that involve backend updates and database schema changes. More specifically, we are using a package migrate-mongo to write our migration files for MongoDB. The migrations are ran automatically via a post-build script that we inserted as part of Heroku's CD.","title":"CI/CD & Workflow"},{"location":"project-overview/implementationdetails/workflow/#implementation-details","text":"","title":"Implementation Details"},{"location":"project-overview/implementationdetails/workflow/#workflow","text":"","title":"Workflow"},{"location":"project-overview/implementationdetails/workflow/#version-control","text":"We used Git and GitHub as our code version control system. For collaboration, we used the pull request (PR) workflow to commit to our master branch. This enables us to stay up to date with what our partner is working on, and also have an extra pair of eyes on code quality.","title":"Version Control"},{"location":"project-overview/implementationdetails/workflow/#continuous-integration-and-continuous-delivery-cicd","text":"We also decided to focus fairly heavily on learning the CI/CD side of DevOps in this project, as we found this knowledge to be invaluable to future software projects that we will be working on. The following is a short summary of the CI/CD workflow we have employed: Continuous Integration Pre-push checks We used husky to run pre-push Git hooks that do code linting, formatting checks and run tests locally before allowing the commit to be pushed to our GitHub repository This ensures that the code on GitHub is formatted and passing our tests before others review/ deploy it GitHub Actions We used GitHub workflow actions in our next step of CI to run the above checks again on GitHub's server to ensure everything is ok This time, we also build the application to ensure that it is ready for deployment GitHub Dependabot GitHub's Dependabot was also set up to check for dependency updates in the packages we use for this project This is extremely convenient as Dependabot automatically sets up PRs and runs our test suite whenever there are packages that can be updated Continuous Delivery Vercel Vercel has a bot that is well integrated with GitHub, and was set up to automatically deploy our production branch with our production configuration This streamlines our frontend deployment as all we have to do is just push to the production branch Heroku Heroku has a similar CD workflow as Vercel, and automatically deploys our production branch with our production configuration whenever there are changes A post-build script is also ran when there are new database migration files","title":"Continuous Integration and Continuous Delivery (CI/CD)"},{"location":"project-overview/implementationdetails/workflow/#database-migrations","text":"We also spent some time working on database migrations as having working knowledge in this aspect will be useful in future software projects that involve backend updates and database schema changes. More specifically, we are using a package migrate-mongo to write our migration files for MongoDB. The migrations are ran automatically via a post-build script that we inserted as part of Heroku's CD.","title":"Database Migrations"},{"location":"project-overview/learningpoints/challenges/","text":"Technical Challenges Overcame Just like any project, we encountered many technical problems and bugs along the way. This page serves to highlight some of the more notable ones, and how we overcame them. Contenteditable divs and ReactJS Contenteditable divs are HTML elements whose content is editable after focusing on them. This enables us to build the seamless-looking UI for the notepage blocks and editable titles, without resorting to HTML form text inputs. However, these contenteditable HTML elements do not play well with React: whenever React rerenders a component containing a contenteditable element, the cursor would jump to the end of the line. This is unacceptable for a notetaking app! Thankfully, after some research, we found a package react-contenteditable which handles this cursor jumping issue (to a certain extent). The tradeoff, as recommended by the library, was that the HTML content was to be stored in a mutable reference ( useRef ) instead of React state ( useState ) and passed into this component. This is because any rerender triggered higher up the component tree would still cause the cursor to jump (recall that setting useState state triggers a rerender while changing useRef state doesn't). As a result, we needed careful thought and handling of our notepage and database views, and only allow rerenders when it does not interfere with the cursor positioning. Real time 'saving' In our initial implementation of the real time 'saving' feature, we updated the backend on every keystroke. This was not ideal as typing a single sentence alone would fire off a dozen or more network requests... To overcome this, we eventually added a window interval with window.setInterval() , and a hasUnsavedChanges boolean mutable ref to check for changes every second or so and update the backend when necessary. On hindsight, we could have utilized WebSocket, which is a persistent connection between the client and the server where both parties can start sending data at any time. This would result in lower latency and would fit our notetaking app use-case better. 'Laggy' UI while waiting for network requests to resolve Network requests are slow. This is a problem for our notetaking app, as the user would reasonably expect instantaneous UI updates for simple CRUD requests like adding a new note, or repositioning a noteblock via dragging. Waiting for the network request to resolve before we can update the UI with the updated information results in undesirable 'laggy' UI. Apollo's implementation of GraphQL contains an option for optimisticResponse , which follows the Optimistic UI pattern (as explained earlier in the section here ). Coupled with the update option, this grants us an easy way of updating our cache, and hence UI, before the network request resolves while handling any state mismatch thereafter. With this, our UI updates instantaneously as one would expect, while updating the backend too. Optimistic UI and 'create' operations In our initial implementation, we used MongoDB generated IDs in our frontend to identify and fetch notes and databases. This became a problem when implementing our optimistic UI, as 'temporary IDs' are created while waiting for the network request to resolve with the actual ID from the backend. Clicking on notes with temporary IDs would result in a note not found error. To overcome this, we considered a few options, such as using a lower latency WebSocket connection. Ultimately, we decided to simply add a loading screen if a note with a tempoary ID is clicked, and load the actual page when the optimistic response returns. Nestable noteblocks To allow indentation and nesting in our noteblocks, we had to restructure noteblocks in the backend into a recursively defined document. This was a problem when trying to fetch noteblocks as frontend GraphQL query schemas cannot be recursively defined. To overcome this, the noteblocks tree-like structure had to be flattened and then passed to the frontend as an array. The frontend then reconverts the array back into a tree. However another problem arose when passing down props to CRUD handlers due to stale closure of React Hooks. Since we update the backend by copying the entire array of noteblocks, CRUD handlers like addBlockHandler and indentBlockHandler need to be passed props containing states of other blocks when updating a single block. These states will get outdated the moment another CRUD handler is triggered. To address this problem, we tried using the onBlur event handlers to trigger a rerender each time a noteblock loses focus. However, this implementation caused visual bugs due to the cursor jumping issue in react-contenteditable . Another problem was that the react-beautiful-dnd library used to create draggable blocks no longer works with the new implementation of noteblocks as the Draggable divs cannot be nested. Due to time constraints, we had to scrap nestable noteblocks for Milestone 3.","title":"Technical Challenges Overcame"},{"location":"project-overview/learningpoints/challenges/#technical-challenges-overcame","text":"Just like any project, we encountered many technical problems and bugs along the way. This page serves to highlight some of the more notable ones, and how we overcame them.","title":"Technical Challenges Overcame"},{"location":"project-overview/learningpoints/challenges/#contenteditable-divs-and-reactjs","text":"Contenteditable divs are HTML elements whose content is editable after focusing on them. This enables us to build the seamless-looking UI for the notepage blocks and editable titles, without resorting to HTML form text inputs. However, these contenteditable HTML elements do not play well with React: whenever React rerenders a component containing a contenteditable element, the cursor would jump to the end of the line. This is unacceptable for a notetaking app! Thankfully, after some research, we found a package react-contenteditable which handles this cursor jumping issue (to a certain extent). The tradeoff, as recommended by the library, was that the HTML content was to be stored in a mutable reference ( useRef ) instead of React state ( useState ) and passed into this component. This is because any rerender triggered higher up the component tree would still cause the cursor to jump (recall that setting useState state triggers a rerender while changing useRef state doesn't). As a result, we needed careful thought and handling of our notepage and database views, and only allow rerenders when it does not interfere with the cursor positioning.","title":"Contenteditable divs and ReactJS"},{"location":"project-overview/learningpoints/challenges/#real-time-saving","text":"In our initial implementation of the real time 'saving' feature, we updated the backend on every keystroke. This was not ideal as typing a single sentence alone would fire off a dozen or more network requests... To overcome this, we eventually added a window interval with window.setInterval() , and a hasUnsavedChanges boolean mutable ref to check for changes every second or so and update the backend when necessary. On hindsight, we could have utilized WebSocket, which is a persistent connection between the client and the server where both parties can start sending data at any time. This would result in lower latency and would fit our notetaking app use-case better.","title":"Real time 'saving'"},{"location":"project-overview/learningpoints/challenges/#laggy-ui-while-waiting-for-network-requests-to-resolve","text":"Network requests are slow. This is a problem for our notetaking app, as the user would reasonably expect instantaneous UI updates for simple CRUD requests like adding a new note, or repositioning a noteblock via dragging. Waiting for the network request to resolve before we can update the UI with the updated information results in undesirable 'laggy' UI. Apollo's implementation of GraphQL contains an option for optimisticResponse , which follows the Optimistic UI pattern (as explained earlier in the section here ). Coupled with the update option, this grants us an easy way of updating our cache, and hence UI, before the network request resolves while handling any state mismatch thereafter. With this, our UI updates instantaneously as one would expect, while updating the backend too.","title":"'Laggy' UI while waiting for network requests to resolve"},{"location":"project-overview/learningpoints/challenges/#optimistic-ui-and-create-operations","text":"In our initial implementation, we used MongoDB generated IDs in our frontend to identify and fetch notes and databases. This became a problem when implementing our optimistic UI, as 'temporary IDs' are created while waiting for the network request to resolve with the actual ID from the backend. Clicking on notes with temporary IDs would result in a note not found error. To overcome this, we considered a few options, such as using a lower latency WebSocket connection. Ultimately, we decided to simply add a loading screen if a note with a tempoary ID is clicked, and load the actual page when the optimistic response returns.","title":"Optimistic UI and 'create' operations"},{"location":"project-overview/learningpoints/challenges/#nestable-noteblocks","text":"To allow indentation and nesting in our noteblocks, we had to restructure noteblocks in the backend into a recursively defined document. This was a problem when trying to fetch noteblocks as frontend GraphQL query schemas cannot be recursively defined. To overcome this, the noteblocks tree-like structure had to be flattened and then passed to the frontend as an array. The frontend then reconverts the array back into a tree. However another problem arose when passing down props to CRUD handlers due to stale closure of React Hooks. Since we update the backend by copying the entire array of noteblocks, CRUD handlers like addBlockHandler and indentBlockHandler need to be passed props containing states of other blocks when updating a single block. These states will get outdated the moment another CRUD handler is triggered. To address this problem, we tried using the onBlur event handlers to trigger a rerender each time a noteblock loses focus. However, this implementation caused visual bugs due to the cursor jumping issue in react-contenteditable . Another problem was that the react-beautiful-dnd library used to create draggable blocks no longer works with the new implementation of noteblocks as the Draggable divs cannot be nested. Due to time constraints, we had to scrap nestable noteblocks for Milestone 3.","title":"Nestable noteblocks"},{"location":"project-overview/learningpoints/skillslearnt/","text":"Skills Learnt As this was the first authenticated web project we have ever done from scratch, we had to pick up many technologies and knowledge along the way. This page seeks to summarise the skills that we have learnt since embarking on this project. For the rationale behind choosing this tech stack, please refer to the earlier page here . ReactJS As the main library for our frontend, we have gained a better understanding of React Hooks and the React Lifecycle when implementing the draggable and contenteditable div UI logic for our notetaking app. We also gained a deeper appreciation of the packages available in the React ecosystem, and where React excels at (and hence its popularity) . Learnt : the latest React Hooks standard, the React Lifecycle , standard React Hooks such as useState , useRef , useCallback , useMemo and when to use them or create custom hooks GraphQL This was our first time using GraphQL in a project, and it was a refreshing take on the whole API call workflow! We really enjoyed using it (Apollo's implementation of GraphQL) and would definitely consider using it again in future projects as opposed to the traditional RESTful API. We really liked: The inbuilt intelligent and normalized cache system without any additional configuration Knows when to refetch data and when to return cached values API which provides finetuned controls for modifying the cache during GraphQL queries or mutations Relieving ourselves of the need to implement our own frontend store with something like Redux, and all the boilerplate code that comes with it... No routing headaches in the backend GraphQL only has a single endpoint through which all queries and mutations are made! No need to work with rigid server-defined endpoints (of RESTful APIs) We can query for a subset of the data returned from a GraphQL query or mutation \u2192 allows us to get the exact data we need without needing to define new queries or mutations, which is not possible with the RESTful API Thus less changes needed in both frontend and backend between software iterations Built-in option for Optimistic Response , which follows the Optimistic UI pattern , and allows for 'snappier' UI and better user experience (crucial to our notetaking app which autosaves periodically when there are changes) Optimistic UI is a pattern that you can use to simulate the results of a mutation and update the UI even before receiving a response from the server. Once the response is received from the server, the optimistic result is thrown away and replaced with the actual result. Optimistic UI provides an easy way to make your UI respond much faster, while ensuring that the data becomes consistent with the actual response when it arrives. ~ Explanation of Optimistic UI by Apollo Built-in GraphQL Playground Allows us to run manual queries or mutations to our GraphQL backend through a GUI without something like Postman or a working frontend Provides a quick sanity check when implementing our GraphQL resolvers What we didn't like: GraphQL is verbose in its own way The GraphQL schema needs to be defined in both the backend, and in every single GraphQL query or mutation called from the frontend (to specify what data and type to return) This can mean a dozen or so lines per query or mutation, as opposed to the one-liner to a RESTful endpoint Worse still, this schema is written as a JavaScript string and is painful to read in a code editor... Sparse documentation and changing specifications GraphQL is still rapidly developing, leading to less robust documentation and changing specifications As it is relatively newer, there are also less forum questions and answers available Bottomline : Whether to use GraphQL or the RESTful API standard really boils down to the tradeoffs one is willing to make, as discussed above Through this project, we can really see the benefits that GraphQL brings to the table, and why many big companies are shifting over to this new paradigm for API development MongoDB This was also our first time using a NoSQL database like MongoDB. Thankfully, with great JavaScript wrapper libraries such as mongoose , we were able to get up to speed quickly and implement the persistence in our notetaking app. Deployment This project opened our eyes to the world of DevOps and CI/CD, and we learnt a great deal about deployment to cloud providers, which is widely used today. We also managed to read up on the various types of cloud computing, such as IaaS, PaaS and SaaS, and the pros and cons of each of these. We also learnt about the handling of secrets and environment variables, and never to expose them in the actual codebase. Click here for more information on the deployment of this project, and here for more information on the CI/CD employed in this project. Authentication This was also our first time implementing authentication for a web app. During the learning process, we researched on the various types of authentication methods that are used today, such as session cookies and OAuth with JSON Web Tokens (JWTs). We also read up on and used PassportJS which is an authentication library in JavaScript. Due to time constraints, we ended up using a library express-session for session cookie authentication, and implemented a simple password login (where the passwords are hashed and stored on the backend - which is not really ideal in a production scenario due to potential security concerns). Given more time, we would have tried implementing the JWT auth flow with 3rd party OAuth providers, such as GitHub, Google or Facebook, or even use OpenID connect. Documentation We decided to use a static site generator for our project documentation, as we can easily organize the content via markdown files. After looking around, we settled on mkdocs-material , and learnt how to write markdown and deploy it to GitHub Pages. GitHub We used Git as our code version control system, and hosted the remote repo on GitHub. Through this project, we gained a deeper understanding of Git's functionality, such as branching , merging and rebasing , and utilized the GitHub pull request workflow for collaboration. This would enable us to collaborate more effectively in future projects of larger scale. We also made use of GitHub's Actions to run our CI checks.","title":"Skills learnt"},{"location":"project-overview/learningpoints/skillslearnt/#skills-learnt","text":"As this was the first authenticated web project we have ever done from scratch, we had to pick up many technologies and knowledge along the way. This page seeks to summarise the skills that we have learnt since embarking on this project. For the rationale behind choosing this tech stack, please refer to the earlier page here .","title":"Skills Learnt"},{"location":"project-overview/learningpoints/skillslearnt/#reactjs","text":"As the main library for our frontend, we have gained a better understanding of React Hooks and the React Lifecycle when implementing the draggable and contenteditable div UI logic for our notetaking app. We also gained a deeper appreciation of the packages available in the React ecosystem, and where React excels at (and hence its popularity) . Learnt : the latest React Hooks standard, the React Lifecycle , standard React Hooks such as useState , useRef , useCallback , useMemo and when to use them or create custom hooks","title":"ReactJS"},{"location":"project-overview/learningpoints/skillslearnt/#graphql","text":"This was our first time using GraphQL in a project, and it was a refreshing take on the whole API call workflow! We really enjoyed using it (Apollo's implementation of GraphQL) and would definitely consider using it again in future projects as opposed to the traditional RESTful API. We really liked: The inbuilt intelligent and normalized cache system without any additional configuration Knows when to refetch data and when to return cached values API which provides finetuned controls for modifying the cache during GraphQL queries or mutations Relieving ourselves of the need to implement our own frontend store with something like Redux, and all the boilerplate code that comes with it... No routing headaches in the backend GraphQL only has a single endpoint through which all queries and mutations are made! No need to work with rigid server-defined endpoints (of RESTful APIs) We can query for a subset of the data returned from a GraphQL query or mutation \u2192 allows us to get the exact data we need without needing to define new queries or mutations, which is not possible with the RESTful API Thus less changes needed in both frontend and backend between software iterations Built-in option for Optimistic Response , which follows the Optimistic UI pattern , and allows for 'snappier' UI and better user experience (crucial to our notetaking app which autosaves periodically when there are changes) Optimistic UI is a pattern that you can use to simulate the results of a mutation and update the UI even before receiving a response from the server. Once the response is received from the server, the optimistic result is thrown away and replaced with the actual result. Optimistic UI provides an easy way to make your UI respond much faster, while ensuring that the data becomes consistent with the actual response when it arrives. ~ Explanation of Optimistic UI by Apollo Built-in GraphQL Playground Allows us to run manual queries or mutations to our GraphQL backend through a GUI without something like Postman or a working frontend Provides a quick sanity check when implementing our GraphQL resolvers What we didn't like: GraphQL is verbose in its own way The GraphQL schema needs to be defined in both the backend, and in every single GraphQL query or mutation called from the frontend (to specify what data and type to return) This can mean a dozen or so lines per query or mutation, as opposed to the one-liner to a RESTful endpoint Worse still, this schema is written as a JavaScript string and is painful to read in a code editor... Sparse documentation and changing specifications GraphQL is still rapidly developing, leading to less robust documentation and changing specifications As it is relatively newer, there are also less forum questions and answers available Bottomline : Whether to use GraphQL or the RESTful API standard really boils down to the tradeoffs one is willing to make, as discussed above Through this project, we can really see the benefits that GraphQL brings to the table, and why many big companies are shifting over to this new paradigm for API development","title":"GraphQL"},{"location":"project-overview/learningpoints/skillslearnt/#mongodb","text":"This was also our first time using a NoSQL database like MongoDB. Thankfully, with great JavaScript wrapper libraries such as mongoose , we were able to get up to speed quickly and implement the persistence in our notetaking app.","title":"MongoDB"},{"location":"project-overview/learningpoints/skillslearnt/#deployment","text":"This project opened our eyes to the world of DevOps and CI/CD, and we learnt a great deal about deployment to cloud providers, which is widely used today. We also managed to read up on the various types of cloud computing, such as IaaS, PaaS and SaaS, and the pros and cons of each of these. We also learnt about the handling of secrets and environment variables, and never to expose them in the actual codebase. Click here for more information on the deployment of this project, and here for more information on the CI/CD employed in this project.","title":"Deployment"},{"location":"project-overview/learningpoints/skillslearnt/#authentication","text":"This was also our first time implementing authentication for a web app. During the learning process, we researched on the various types of authentication methods that are used today, such as session cookies and OAuth with JSON Web Tokens (JWTs). We also read up on and used PassportJS which is an authentication library in JavaScript. Due to time constraints, we ended up using a library express-session for session cookie authentication, and implemented a simple password login (where the passwords are hashed and stored on the backend - which is not really ideal in a production scenario due to potential security concerns). Given more time, we would have tried implementing the JWT auth flow with 3rd party OAuth providers, such as GitHub, Google or Facebook, or even use OpenID connect.","title":"Authentication"},{"location":"project-overview/learningpoints/skillslearnt/#documentation","text":"We decided to use a static site generator for our project documentation, as we can easily organize the content via markdown files. After looking around, we settled on mkdocs-material , and learnt how to write markdown and deploy it to GitHub Pages.","title":"Documentation"},{"location":"project-overview/learningpoints/skillslearnt/#github","text":"We used Git as our code version control system, and hosted the remote repo on GitHub. Through this project, we gained a deeper understanding of Git's functionality, such as branching , merging and rebasing , and utilized the GitHub pull request workflow for collaboration. This would enable us to collaborate more effectively in future projects of larger scale. We also made use of GitHub's Actions to run our CI checks.","title":"GitHub"}]}